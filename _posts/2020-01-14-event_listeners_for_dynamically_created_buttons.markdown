---
layout: post
title:      "Event Listeners for Dynamically Created Buttons"
date:       2020-01-14 18:27:05 +0000
permalink:  event_listeners_for_dynamically_created_buttons
---


Anyone who's worked with event listeners in a single page application has run into the issue of trying to assign an event listener to an element that does not exist yet. You know you will have this button, but it just isn't there yet when your event listeners are being set, and going back to set the listener once the button has appeared can be cumbersome and code heavy. While creating my application, I found a very elegant solution for this problem. Before moving on, the tree structure for my code looked a bit like this:

* Each page was generated by a Page Manager, which loaded the content and set the event listeners.
* The API that I was pulling from was a simple Rails API.
* Most existing buttons on my page had event listeners that generated other buttons - hence, dynamically created buttons.

So, to set event listeners on these buttons that did not get the initial round of event listeners I structured the function that set my bindings like this:

```
initBindingsAndEventListeners() {
        this.expenses.setEditButtonListener();

        const weddingPage = this.parent.router.routes.wedding
				
        this.container.addEventListener('click',function(e){
            if (e.target.type !== "checkbox") {
                e.preventDefault()
                if(e.target && e.target.id === 'expenseSubmit'){
                    weddingPage.expenses.handleExpenseEditSubmit(e)
                }
            }
         });
    }
```

Lets break that down.

This sets a standard event listener on a button that already exists on the page:
```this.expenses.setEditButtonListener();```

A variable is declared to reference the page. This is necessary because in the callbacks for the event listeners being set on the dynamically created buttons are functions of the page manager, or the data manager. Within the next block of code, which itself is an event listener, 'this' would refer the the element that *that* listener is being set to, not the page manager as I need it to.
```const weddingPage = this.parent.router.routes.wedding```

This is the tricky bit. An event listener is set to the entire container, for any click. (This could also just be called on the window if you are not using containers - but I wanted to only set it to a specific section of the page.) When a click is detected anywhere within the container, it will see what the target was, and check whether the target had the specific id of a dynamically created button. If so, it would fire the callback function that should handle that button.
```
        this.container.addEventListener('click',function(e){
            if (e.target.type !== "checkbox") {
                e.preventDefault()
                if(e.target && e.target.id === 'expenseSubmit'){
                    weddingPage.expenses.handleExpenseEditSubmit(e)
                }
            }
         });
```

Presto! Your dynamic button now works!

**But...** you may have noticed that little if statement - the one about the checkboxes? That became necessary after a fairly confusing bug popped up. One form in my application has both a dynamically created button for a form that has checkboxes. By setting the event listener for the entire container, and preventing the default action of everything but the specified dynamic buttons, checkboxes were no longer checkable because the listener was preventing the default action of a checkbox. So I needed to specify that only if the click was NOT a checkbox, handle the click.

So if you have checkboxes, and I also suspect radio buttons would be affected by this side effect,  you will need to specify that they should still do what they're supposed to.

